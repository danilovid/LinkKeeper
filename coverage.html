
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api-service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/danilovid/linkkeeper/cmd/api-service/main.go (0.0%)</option>
				
				<option value="file1">github.com/danilovid/linkkeeper/cmd/bot-service/main.go (0.0%)</option>
				
				<option value="file2">github.com/danilovid/linkkeeper/cmd/user-service/main.go (0.0%)</option>
				
				<option value="file3">github.com/danilovid/linkkeeper/internal/api-service/repository/link.go (0.0%)</option>
				
				<option value="file4">github.com/danilovid/linkkeeper/internal/api-service/transport/http/http.go (0.0%)</option>
				
				<option value="file5">github.com/danilovid/linkkeeper/internal/api-service/transport/http/routers.go (0.0%)</option>
				
				<option value="file6">github.com/danilovid/linkkeeper/internal/api-service/usecase/link.go (52.2%)</option>
				
				<option value="file7">github.com/danilovid/linkkeeper/internal/bot-service/api/client.go (0.0%)</option>
				
				<option value="file8">github.com/danilovid/linkkeeper/internal/bot-service/bot/config.go (0.0%)</option>
				
				<option value="file9">github.com/danilovid/linkkeeper/internal/bot-service/bot/wrapper.go (0.0%)</option>
				
				<option value="file10">github.com/danilovid/linkkeeper/internal/bot-service/user/client.go (0.0%)</option>
				
				<option value="file11">github.com/danilovid/linkkeeper/internal/user-service/models.go (0.0%)</option>
				
				<option value="file12">github.com/danilovid/linkkeeper/internal/user-service/repository/user.go (86.4%)</option>
				
				<option value="file13">github.com/danilovid/linkkeeper/internal/user-service/transport/http/http.go (58.5%)</option>
				
				<option value="file14">github.com/danilovid/linkkeeper/internal/user-service/transport/http/routers.go (0.0%)</option>
				
				<option value="file15">github.com/danilovid/linkkeeper/internal/user-service/usecase/user.go (100.0%)</option>
				
				<option value="file16">github.com/danilovid/linkkeeper/pkg/config/config.go (0.0%)</option>
				
				<option value="file17">github.com/danilovid/linkkeeper/pkg/database/postgresql/postgresql.go (0.0%)</option>
				
				<option value="file18">github.com/danilovid/linkkeeper/pkg/httpclient/client.go (0.0%)</option>
				
				<option value="file19">github.com/danilovid/linkkeeper/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"

        repo "github.com/danilovid/linkkeeper/internal/api-service/repository"
        "github.com/danilovid/linkkeeper/internal/api-service/transport/http"
        "github.com/danilovid/linkkeeper/internal/api-service/usecase"
        "github.com/danilovid/linkkeeper/pkg/config"
        "github.com/danilovid/linkkeeper/pkg/database/postgresql"
        "github.com/danilovid/linkkeeper/pkg/httpclient"
        "github.com/danilovid/linkkeeper/pkg/logger"
)

const shutdownTimeout = 5 * time.Second

func main() <span class="cov0" title="0">{
        cfg := config.New()

        logger.Init()

        db := postgresql.New(cfg.PostgresDSN, &amp;repo.LinkModel{})
        linkRepo := repo.NewLinkRepo(db)
        linkSvc := usecase.NewLinkService(linkRepo)

        httpSrv := http.NewServer(linkSvc)
        srv := httpclient.New(cfg.HTTPAddr, httpSrv.Handler(), nil)

        go func() </span><span class="cov0" title="0">{
                logger.L().Info().Str("addr", cfg.HTTPAddr).Msg("api listening")
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        logger.L().Fatal().Err(err).Msg("http server")
                }</span>
        }()

        <span class="cov0" title="0">waitForShutdown(func() </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
                defer cancel()
                _ = srv.Shutdown(ctx)
        }</span>)
}

func waitForShutdown(fn func()) <span class="cov0" title="0">{
        ch := make(chan os.Signal, 1)
        signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
        &lt;-ch
        fn()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "os"
        "strconv"
        "time"

        "github.com/danilovid/linkkeeper/internal/bot-service/bot"
        "github.com/danilovid/linkkeeper/pkg/logger"
)

const defaultTimeout = 10 * time.Second

func main() <span class="cov0" title="0">{
        logger.Init()

        cfg := bot.Config{
                Token:          os.Getenv("TELEGRAM_TOKEN"),
                APIBaseURL:     os.Getenv("API_BASE_URL"),
                UserServiceURL: os.Getenv("USER_SERVICE_URL"),
                Timeout:        readTimeout(),
        }

        w, err := bot.NewWrapper(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.L().Fatal().Err(err).Msg("init bot")
        }</span>

        <span class="cov0" title="0">logger.L().Info().Msg("bot started")
        if err := w.Start(); err != nil </span><span class="cov0" title="0">{
                logger.L().Fatal().Err(err).Msg("bot stopped")
        }</span>
}

func readTimeout() time.Duration <span class="cov0" title="0">{
        raw := os.Getenv("BOT_TIMEOUT_SECONDS")
        if raw == "" </span><span class="cov0" title="0">{
                return defaultTimeout
        }</span>
        <span class="cov0" title="0">seconds, err := strconv.Atoi(raw)
        if err != nil || seconds &lt;= 0 </span><span class="cov0" title="0">{
                return defaultTimeout
        }</span>
        <span class="cov0" title="0">return time.Duration(seconds) * time.Second</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"

        repo "github.com/danilovid/linkkeeper/internal/user-service/repository"
        "github.com/danilovid/linkkeeper/internal/user-service/transport/http"
        "github.com/danilovid/linkkeeper/internal/user-service/usecase"
        "github.com/danilovid/linkkeeper/pkg/config"
        "github.com/danilovid/linkkeeper/pkg/database/postgresql"
        "github.com/danilovid/linkkeeper/pkg/httpclient"
        "github.com/danilovid/linkkeeper/pkg/logger"

        userservice "github.com/danilovid/linkkeeper/internal/user-service"
)

const shutdownTimeout = 5 * time.Second

func main() <span class="cov0" title="0">{
        cfg := config.New()

        logger.Init()

        db := postgresql.New(cfg.PostgresDSN, &amp;userservice.UserModel{})
        userRepo := repo.NewUserRepo(db)
        userSvc := usecase.NewUserService(userRepo)

        httpSrv := http.NewServer(userSvc)
        srv := httpclient.New(cfg.HTTPAddr, httpSrv.Handler(), nil)

        go func() </span><span class="cov0" title="0">{
                logger.L().Info().Str("addr", cfg.HTTPAddr).Msg("user-service listening")
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        logger.L().Fatal().Err(err).Msg("http server")
                }</span>
        }()

        <span class="cov0" title="0">waitForShutdown(func() </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
                defer cancel()
                _ = srv.Shutdown(ctx)
        }</span>)
}

func waitForShutdown(fn func()) <span class="cov0" title="0">{
        ch := make(chan os.Signal, 1)
        signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
        &lt;-ch
        fn()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package repository

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        apiservice "github.com/danilovid/linkkeeper/internal/api-service"
)

type LinkRepo struct {
        db *gorm.DB
}

func NewLinkRepo(db *gorm.DB) *LinkRepo <span class="cov0" title="0">{
        return &amp;LinkRepo{db: db}
}</span>

type LinkModel struct {
        ID        string     `gorm:"type:uuid;primaryKey"`
        URL       string     `gorm:"not null"`
        Resource  string     `gorm:"not null;default:''"`
        Views     int64      `gorm:"not null;default:0"`
        ViewedAt  *time.Time `gorm:"default:null"`
        CreatedAt time.Time  `gorm:"autoCreateTime"`
        UpdatedAt time.Time  `gorm:"autoUpdateTime"`
}

func (r *LinkRepo) Create(ctx context.Context, input apiservice.LinkCreateInput) (apiservice.Link, error) <span class="cov0" title="0">{
        model := LinkModel{
                ID:       uuid.NewString(),
                URL:      input.URL,
                Resource: input.Resource,
        }
        if err := r.db.WithContext(ctx).Create(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                return apiservice.Link{}, err
        }</span>
        <span class="cov0" title="0">return toLink(model), nil</span>
}

func (r *LinkRepo) GetByID(ctx context.Context, id string) (apiservice.Link, error) <span class="cov0" title="0">{
        var model LinkModel
        if err := r.db.WithContext(ctx).First(&amp;model, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return apiservice.Link{}, mapErr(err)
        }</span>
        <span class="cov0" title="0">return toLink(model), nil</span>
}

func (r *LinkRepo) List(ctx context.Context, limit, offset int) ([]apiservice.Link, error) <span class="cov0" title="0">{
        var models []LinkModel
        if err := r.db.WithContext(ctx).
                Order("created_at desc").
                Limit(limit).
                Offset(offset).
                Find(&amp;models).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">out := make([]apiservice.Link, 0, len(models))
        for _, m := range models </span><span class="cov0" title="0">{
                out = append(out, toLink(m))
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (r *LinkRepo) Random(ctx context.Context, resource string) (apiservice.Link, error) <span class="cov0" title="0">{
        var model LinkModel
        q := r.db.WithContext(ctx).Model(&amp;LinkModel{})
        if resource != "" </span><span class="cov0" title="0">{
                q = q.Where("resource = ?", resource)
        }</span>
        <span class="cov0" title="0">if err := q.Order("random()").Limit(1).Take(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                return apiservice.Link{}, mapErr(err)
        }</span>
        <span class="cov0" title="0">return toLink(model), nil</span>
}

func (r *LinkRepo) Update(ctx context.Context, id string, input apiservice.LinkUpdateInput) (apiservice.Link, error) <span class="cov0" title="0">{
        updates := map[string]any{}
        if input.URL != nil </span><span class="cov0" title="0">{
                updates["url"] = *input.URL
        }</span>
        <span class="cov0" title="0">if input.Resource != nil </span><span class="cov0" title="0">{
                updates["resource"] = *input.Resource
        }</span>
        <span class="cov0" title="0">if len(updates) &gt; 0 </span><span class="cov0" title="0">{
                res := r.db.WithContext(ctx).
                        Model(&amp;LinkModel{}).
                        Where("id = ?", id).
                        Updates(updates)
                if res.Error != nil </span><span class="cov0" title="0">{
                        return apiservice.Link{}, res.Error
                }</span>
                <span class="cov0" title="0">if res.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return apiservice.Link{}, apiservice.ErrNotFound
                }</span>
        }
        <span class="cov0" title="0">return r.GetByID(ctx, id)</span>
}

func (r *LinkRepo) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        res := r.db.WithContext(ctx).Delete(&amp;LinkModel{}, "id = ?", id)
        if res.Error != nil </span><span class="cov0" title="0">{
                return res.Error
        }</span>
        <span class="cov0" title="0">if res.RowsAffected == 0 </span><span class="cov0" title="0">{
                return apiservice.ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LinkRepo) MarkViewed(ctx context.Context, id string) (apiservice.Link, error) <span class="cov0" title="0">{
        now := time.Now()
        res := r.db.WithContext(ctx).
                Model(&amp;LinkModel{}).
                Where("id = ?", id).
                Updates(map[string]any{
                        "views":     gorm.Expr("views + 1"),
                        "viewed_at": &amp;now,
                })
        if res.Error != nil </span><span class="cov0" title="0">{
                return apiservice.Link{}, res.Error
        }</span>
        <span class="cov0" title="0">if res.RowsAffected == 0 </span><span class="cov0" title="0">{
                return apiservice.Link{}, apiservice.ErrNotFound
        }</span>
        <span class="cov0" title="0">return r.GetByID(ctx, id)</span>
}

func (r *LinkRepo) GetViewStats(ctx context.Context, days int) ([]apiservice.ViewStats, error) <span class="cov0" title="0">{
        if days &lt;= 0 </span><span class="cov0" title="0">{
                days = 53
        }</span>
        <span class="cov0" title="0">if days &gt; 365 </span><span class="cov0" title="0">{
                days = 365
        }</span>

        <span class="cov0" title="0">type resultRow struct {
                Date  string `gorm:"column:date"`
                Count int64  `gorm:"column:count"`
        }
        var results []resultRow
        startDate := time.Now().AddDate(0, 0, -days+1).Truncate(24 * time.Hour)
        err := r.db.WithContext(ctx).
                Model(&amp;LinkModel{}).
                Select("DATE(viewed_at)::text as date, COUNT(*)::bigint as count").
                Where("viewed_at IS NOT NULL").
                Where("viewed_at &gt;= ?", startDate).
                Group("DATE(viewed_at)").
                Order("date ASC").
                Scan(&amp;results).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">statsMap := make(map[string]int64)
        for _, r := range results </span><span class="cov0" title="0">{
                statsMap[r.Date] = r.Count
        }</span>

        <span class="cov0" title="0">var maxCount int64
        for _, count := range statsMap </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                }</span>
        }

        <span class="cov0" title="0">now := time.Now()
        stats := make([]apiservice.ViewStats, 0, days)
        for i := days - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                date := now.AddDate(0, 0, -i)
                dateStr := date.Format("2006-01-02")

                count := statsMap[dateStr]
                level := 0
                if maxCount &gt; 0 </span><span class="cov0" title="0">{
                        ratio := float64(count) / float64(maxCount)
                        if ratio &gt; 0.8 </span><span class="cov0" title="0">{
                                level = 4
                        }</span> else<span class="cov0" title="0"> if ratio &gt; 0.6 </span><span class="cov0" title="0">{
                                level = 3
                        }</span> else<span class="cov0" title="0"> if ratio &gt; 0.4 </span><span class="cov0" title="0">{
                                level = 2
                        }</span> else<span class="cov0" title="0"> if ratio &gt; 0.2 </span><span class="cov0" title="0">{
                                level = 1
                        }</span>
                }

                <span class="cov0" title="0">stats = append(stats, apiservice.ViewStats{
                        Date:  dateStr,
                        Count: count,
                        Level: level,
                })</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

func mapErr(err error) error <span class="cov0" title="0">{
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return apiservice.ErrNotFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func toLink(m LinkModel) apiservice.Link <span class="cov0" title="0">{
        return apiservice.Link{
                ID:        m.ID,
                URL:       m.URL,
                Resource:  m.Resource,
                Views:     m.Views,
                ViewedAt:  m.ViewedAt,
                CreatedAt: m.CreatedAt,
                UpdatedAt: m.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import (
        "net/http"
        "time"

        "github.com/gorilla/mux"
        "github.com/justinas/alice"

        apiservice "github.com/danilovid/linkkeeper/internal/api-service"
        "github.com/danilovid/linkkeeper/pkg/logger"
        "github.com/rs/cors"
)

type Server struct {
        uc      apiservice.LinkService
        router  *mux.Router
        handler http.Handler
}

func NewServer(uc apiservice.LinkService) *Server <span class="cov0" title="0">{
        r := mux.NewRouter()
        s := &amp;Server{
                uc:     uc,
                router: r,
        }
        s.routes()
        return s
}</span>

func (s *Server) Handler() http.Handler <span class="cov0" title="0">{
        return s.handler
}</span>

func (s *Server) routes() <span class="cov0" title="0">{
        s.router.StrictSlash(true)

        corsOpts := cors.Options{
                AllowedOrigins: []string{"*"},
                AllowedMethods: []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
                AllowedHeaders: []string{"Origin", "Accept", "Content-Type", "X-Requested-With", "Authorization", "X-Auth-Key"},
        }

        s.handler = alice.New(
                requestLogger,
                cors.New(corsOpts).Handler,
        ).Then(s.router)

        s.router.HandleFunc("/health", Health).Methods(http.MethodGet)

        api := s.router.PathPrefix("/api/v1").Subrouter()
        api.HandleFunc("/links", s.Create()).Methods(http.MethodPost)
        api.HandleFunc("/links", s.List()).Methods(http.MethodGet)
        api.HandleFunc("/links/random", s.Random()).Methods(http.MethodGet)
        api.HandleFunc("/links/{id}", s.Get()).Methods(http.MethodGet)
        api.HandleFunc("/links/{id}", s.Update()).Methods(http.MethodPatch)
        api.HandleFunc("/links/{id}", s.Delete()).Methods(http.MethodDelete)
        api.HandleFunc("/links/{id}/viewed", s.MarkViewed()).Methods(http.MethodPost)
        api.HandleFunc("/stats/views", s.GetViewStats()).Methods(http.MethodGet)
}</span>

func requestLogger(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                next.ServeHTTP(w, r)
                logger.L().Info().
                        Str("method", r.Method).
                        Str("path", r.URL.Path).
                        Dur("duration", time.Since(start)).
                        Msg("request")
        }</span>)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package http

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"

        apiservice "github.com/danilovid/linkkeeper/internal/api-service"
)

type createLinkRequest struct {
        URL      string `json:"url"`
        Resource string `json:"resource"`
}

type updateLinkRequest struct {
        URL      *string `json:"url"`
        Resource *string `json:"resource"`
}

type linkResponse struct {
        ID        string     `json:"id"`
        URL       string     `json:"url"`
        Resource  string     `json:"resource,omitempty"`
        Views     int64      `json:"views"`
        ViewedAt  *time.Time `json:"viewed_at,omitempty"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
}

func Health(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
}</span>

func (s *Server) Create() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var req createLinkRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "bad json", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">req.URL = strings.TrimSpace(req.URL)
                req.Resource = strings.TrimSpace(req.Resource)
                input := apiservice.LinkCreateInput{
                        URL:      req.URL,
                        Resource: req.Resource,
                }
                link, err := s.uc.Create(r.Context(), input)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusCreated, toLinkResponse(link))</span>
        }
}

func (s *Server) Get() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                id := mux.Vars(r)["id"]
                link, err := s.uc.GetByID(r.Context(), id)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusOK, toLinkResponse(link))</span>
        }
}

func (s *Server) List() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                limit := parseIntDefault(r.URL.Query().Get("limit"), 50)
                offset := parseIntDefault(r.URL.Query().Get("offset"), 0)
                if limit &gt; 200 </span><span class="cov0" title="0">{
                        limit = 200
                }</span>
                <span class="cov0" title="0">links, err := s.uc.List(r.Context(), limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">resp := make([]linkResponse, 0, len(links))
                for _, link := range links </span><span class="cov0" title="0">{
                        resp = append(resp, toLinkResponse(link))
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusOK, resp)</span>
        }
}

func (s *Server) Random() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                resource := strings.TrimSpace(r.URL.Query().Get("resource"))
                link, err := s.uc.Random(r.Context(), resource)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusOK, toLinkResponse(link))</span>
        }
}

func (s *Server) Update() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                id := mux.Vars(r)["id"]
                var req updateLinkRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "bad json", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">if req.URL != nil </span><span class="cov0" title="0">{
                        trimmed := strings.TrimSpace(*req.URL)
                        req.URL = &amp;trimmed
                }</span>
                <span class="cov0" title="0">if req.Resource != nil </span><span class="cov0" title="0">{
                        trimmed := strings.TrimSpace(*req.Resource)
                        req.Resource = &amp;trimmed
                }</span>
                <span class="cov0" title="0">input := apiservice.LinkUpdateInput{
                        URL:      req.URL,
                        Resource: req.Resource,
                }
                link, err := s.uc.Update(r.Context(), id, input)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusOK, toLinkResponse(link))</span>
        }
}

func (s *Server) Delete() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                id := mux.Vars(r)["id"]
                if err := s.uc.Delete(r.Context(), id); err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
        }
}

func (s *Server) MarkViewed() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                id := mux.Vars(r)["id"]
                link, err := s.uc.MarkViewed(r.Context(), id)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusOK, toLinkResponse(link))</span>
        }
}

func (s *Server) GetViewStats() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                days := parseIntDefault(r.URL.Query().Get("days"), 53)
                if days &gt; 365 </span><span class="cov0" title="0">{
                        days = 365
                }</span>
                <span class="cov0" title="0">stats, err := s.uc.GetViewStats(r.Context(), days)
                if err != nil </span><span class="cov0" title="0">{
                        writeError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">writeJSON(w, http.StatusOK, stats)</span>
        }
}

func writeJSON(w http.ResponseWriter, status int, v any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(v)
}</span>

func writeError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        switch </span>{
        case errors.Is(err, apiservice.ErrNotFound):<span class="cov0" title="0">
                http.Error(w, "not found", http.StatusNotFound)</span>
        case errors.Is(err, apiservice.ErrInvalidInput):<span class="cov0" title="0">
                http.Error(w, err.Error(), http.StatusBadRequest)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "internal error", http.StatusInternalServerError)</span>
        }
}

func toLinkResponse(link apiservice.Link) linkResponse <span class="cov0" title="0">{
        return linkResponse{
                ID:        link.ID,
                URL:       link.URL,
                Resource:  link.Resource,
                Views:     link.Views,
                ViewedAt:  link.ViewedAt,
                CreatedAt: link.CreatedAt,
                UpdatedAt: link.UpdatedAt,
        }
}</span>

func parseIntDefault(raw string, def int) int <span class="cov0" title="0">{
        if raw == "" </span><span class="cov0" title="0">{
                return def
        }</span>
        <span class="cov0" title="0">parsed, err := strconv.Atoi(raw)
        if err != nil </span><span class="cov0" title="0">{
                return def
        }</span>
        <span class="cov0" title="0">return parsed</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package usecase

import (
        "context"
        "fmt"

        apiservice "github.com/danilovid/linkkeeper/internal/api-service"
)

type LinkService struct {
        repo apiservice.LinkRepository
}

func NewLinkService(repo apiservice.LinkRepository) *LinkService <span class="cov10" title="9">{
        return &amp;LinkService{repo: repo}
}</span>

func (s *LinkService) Create(ctx context.Context, input apiservice.LinkCreateInput) (apiservice.Link, error) <span class="cov5" title="3">{
        if err := validateCreate(input); err != nil </span><span class="cov0" title="0">{
                return apiservice.Link{}, err
        }</span>
        <span class="cov5" title="3">return s.repo.Create(ctx, input)</span>
}

func (s *LinkService) GetByID(ctx context.Context, id string) (apiservice.Link, error) <span class="cov3" title="2">{
        return s.repo.GetByID(ctx, id)
}</span>

func (s *LinkService) List(ctx context.Context, limit, offset int) ([]apiservice.Link, error) <span class="cov3" title="2">{
        return s.repo.List(ctx, limit, offset)
}</span>

func (s *LinkService) Random(ctx context.Context, resource string) (apiservice.Link, error) <span class="cov3" title="2">{
        return s.repo.Random(ctx, resource)
}</span>

func (s *LinkService) Update(ctx context.Context, id string, input apiservice.LinkUpdateInput) (apiservice.Link, error) <span class="cov0" title="0">{
        if err := validateUpdate(input); err != nil </span><span class="cov0" title="0">{
                return apiservice.Link{}, err
        }</span>
        <span class="cov0" title="0">return s.repo.Update(ctx, id, input)</span>
}

func (s *LinkService) Delete(ctx context.Context, id string) error <span class="cov1" title="1">{
        return s.repo.Delete(ctx, id)
}</span>

func (s *LinkService) MarkViewed(ctx context.Context, id string) (apiservice.Link, error) <span class="cov1" title="1">{
        return s.repo.MarkViewed(ctx, id)
}</span>

func (s *LinkService) GetViewStats(ctx context.Context, days int) ([]apiservice.ViewStats, error) <span class="cov1" title="1">{
        if days &lt;= 0 </span><span class="cov0" title="0">{
                days = 53
        }</span>
        <span class="cov1" title="1">return s.repo.GetViewStats(ctx, days)</span>
}

func validateCreate(input apiservice.LinkCreateInput) error <span class="cov5" title="3">{
        if input.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: url is required", apiservice.ErrInvalidInput)
        }</span>
        <span class="cov5" title="3">return nil</span>
}

func validateUpdate(input apiservice.LinkUpdateInput) error <span class="cov0" title="0">{
        if input.URL == nil &amp;&amp; input.Resource == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: no fields to update", apiservice.ErrInvalidInput)
        }</span>
        <span class="cov0" title="0">if input.URL != nil &amp;&amp; *input.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: url is required", apiservice.ErrInvalidInput)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"
)

type Client struct {
        baseURL string
        http    *http.Client
}

type Link struct {
        ID       string `json:"id"`
        URL      string `json:"url"`
        Resource string `json:"resource"`
}

func NewClient(baseURL string, timeout time.Duration) *Client <span class="cov0" title="0">{
        return &amp;Client{
                baseURL: strings.TrimRight(baseURL, "/"),
                http:    &amp;http.Client{Timeout: timeout},
        }
}</span>

func (c *Client) CreateLink(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        payload, err := json.Marshal(map[string]string{"url": url})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/api/v1/links", bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("api status: %s", resp.Status)
        }</span>
        <span class="cov0" title="0">var out struct {
                ID string `json:"id"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;out); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return out.ID, nil</span>
}

func (c *Client) MarkViewed(ctx context.Context, id string) error <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/api/v1/links/"+id+"/viewed", http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("api status: %s", resp.Status)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) RandomLink(ctx context.Context, resource string) (Link, error) <span class="cov0" title="0">{
        requestURL := c.baseURL + "/api/v1/links/random"
        if resource != "" </span><span class="cov0" title="0">{
                requestURL += "?resource=" + url.QueryEscape(resource)
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "GET", requestURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return Link{}, err
        }</span>
        <span class="cov0" title="0">resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return Link{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return Link{}, fmt.Errorf("api status: %s", resp.Status)
        }</span>
        <span class="cov0" title="0">var out Link
        if err := json.NewDecoder(resp.Body).Decode(&amp;out); err != nil </span><span class="cov0" title="0">{
                return Link{}, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package bot

import (
        "errors"
        "strings"
        "time"
)

type Config struct {
        Token          string
        APIBaseURL     string
        UserServiceURL string
        Timeout        time.Duration
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        if strings.TrimSpace(c.Token) == "" </span><span class="cov0" title="0">{
                return errors.New("missing TELEGRAM_TOKEN")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(c.APIBaseURL) == "" </span><span class="cov0" title="0">{
                return errors.New("missing API_BASE_URL")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(c.UserServiceURL) == "" </span><span class="cov0" title="0">{
                return errors.New("missing USER_SERVICE_URL")
        }</span>
        <span class="cov0" title="0">if c.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                c.Timeout = 10 * time.Second
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package bot

import (
        "context"
        "strings"

        "github.com/danilovid/linkkeeper/internal/bot-service/api"
        "github.com/danilovid/linkkeeper/internal/bot-service/user"
        "github.com/danilovid/linkkeeper/pkg/logger"
        tb "gopkg.in/telebot.v4"
        "gopkg.in/telebot.v4/middleware"
)

type Wrapper struct {
        bot         *tb.Bot
        config      *Config
        api         *api.Client
        userService *user.Client
}

var (
        menu = &amp;tb.ReplyMarkup{ResizeKeyboard: true}

        btnSave          = menu.Text("ðŸ’¾ Save link")
        btnViewed        = menu.Text("âœ… Mark viewed")
        btnRandom        = menu.Text("ðŸŽ² Random")
        btnRandomArticle = menu.Text("ðŸ“° Random article")
        btnRandomVideo   = menu.Text("ðŸŽ¬ Random video")
)

func NewWrapper(config *Config) (*Wrapper, error) <span class="cov0" title="0">{
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">settings := tb.Settings{
                Token:  config.Token,
                Poller: &amp;tb.LongPoller{Timeout: config.Timeout},
        }

        b, err := tb.NewBot(settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">b.Use(middleware.Logger())
        b.Use(middleware.AutoRespond())

        w := &amp;Wrapper{
                bot:         b,
                config:      config,
                api:         api.NewClient(config.APIBaseURL, config.Timeout),
                userService: user.NewClient(config.UserServiceURL, config.Timeout),
        }
        w.prepare()
        return w, nil</span>
}

func (w *Wrapper) Start() error <span class="cov0" title="0">{
        w.bot.Start()
        return nil
}</span>

func (w *Wrapper) prepare() <span class="cov0" title="0">{
        menu.Reply(
                menu.Row(btnSave, btnViewed),
                menu.Row(btnRandom),
                menu.Row(btnRandomArticle, btnRandomVideo),
        )

        w.bot.Handle("/start", func(c tb.Context) error </span><span class="cov0" title="0">{
                sender := c.Sender()
                if sender != nil </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        _, err := w.userService.GetOrCreateUser(
                                ctx,
                                sender.ID,
                                sender.Username,
                                sender.FirstName,
                                sender.LastName,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                logger.L().Error().Err(err).Int64("telegram_id", sender.ID).Msg("failed to get or create user")
                        }</span> else<span class="cov0" title="0"> {
                                logger.L().Info().Int64("telegram_id", sender.ID).Str("username", sender.Username).Msg("user registered or retrieved")
                        }</span>
                }
                <span class="cov0" title="0">return c.Send("Welcome! Choose an action:", menu)</span>
        })

        <span class="cov0" title="0">w.bot.Handle("/save", func(c tb.Context) error </span><span class="cov0" title="0">{
                url := strings.TrimSpace(c.Message().Payload)
                if url == "" </span><span class="cov0" title="0">{
                        return c.Send("usage: /save &lt;url&gt;")
                }</span>
                <span class="cov0" title="0">ctx := context.Background()
                id, err := w.api.CreateLink(ctx, url)
                if err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Str("url", url).Msg("create link failed")
                        return c.Send("failed to save link")
                }</span>
                <span class="cov0" title="0">return c.Send("saved âœ… id: " + id)</span>
        })

        <span class="cov0" title="0">w.bot.Handle("/viewed", func(c tb.Context) error </span><span class="cov0" title="0">{
                id := strings.TrimSpace(c.Message().Payload)
                if id == "" </span><span class="cov0" title="0">{
                        return c.Send("usage: /viewed &lt;id&gt;")
                }</span>
                <span class="cov0" title="0">ctx := context.Background()
                if err := w.api.MarkViewed(ctx, id); err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Str("id", id).Msg("mark viewed failed")
                        return c.Send("failed to mark viewed")
                }</span>
                <span class="cov0" title="0">return c.Send("marked viewed âœ…")</span>
        })

        <span class="cov0" title="0">w.bot.Handle("/random", func(c tb.Context) error </span><span class="cov0" title="0">{
                resource := strings.TrimSpace(c.Message().Payload)
                ctx := context.Background()
                link, err := w.api.RandomLink(ctx, resource)
                if err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Str("resource", resource).Msg("random link failed")
                        return c.Send("failed to get random link")
                }</span>
                <span class="cov0" title="0">if link.URL == "" </span><span class="cov0" title="0">{
                        return c.Send("no links found")
                }</span>
                <span class="cov0" title="0">msg := "random âœ…\n" + link.URL + "\nID: " + link.ID
                if link.Resource != "" </span><span class="cov0" title="0">{
                        msg += "\nResource: " + link.Resource
                }</span>
                <span class="cov0" title="0">return c.Send(msg, menu)</span>
        })

        <span class="cov0" title="0">w.bot.Handle(&amp;btnSave, func(c tb.Context) error </span><span class="cov0" title="0">{
                return c.Send("Send link: /save &lt;url&gt;", menu)
        }</span>)

        <span class="cov0" title="0">w.bot.Handle(&amp;btnViewed, func(c tb.Context) error </span><span class="cov0" title="0">{
                return c.Send("Send id: /viewed &lt;id&gt;", menu)
        }</span>)

        <span class="cov0" title="0">w.bot.Handle(&amp;btnRandom, func(c tb.Context) error </span><span class="cov0" title="0">{
                ctx := context.Background()
                link, err := w.api.RandomLink(ctx, "")
                if err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Msg("random link failed")
                        return c.Send("failed to get random link", menu)
                }</span>
                <span class="cov0" title="0">if link.URL == "" </span><span class="cov0" title="0">{
                        return c.Send("no links found", menu)
                }</span>
                <span class="cov0" title="0">msg := "random âœ…\n" + link.URL + "\nID: " + link.ID
                if link.Resource != "" </span><span class="cov0" title="0">{
                        msg += "\nResource: " + link.Resource
                }</span>
                <span class="cov0" title="0">return c.Send(msg, menu)</span>
        })

        <span class="cov0" title="0">w.bot.Handle(&amp;btnRandomArticle, func(c tb.Context) error </span><span class="cov0" title="0">{
                ctx := context.Background()
                link, err := w.api.RandomLink(ctx, "article")
                if err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Msg("random article failed")
                        return c.Send("failed to get random article", menu)
                }</span>
                <span class="cov0" title="0">if link.URL == "" </span><span class="cov0" title="0">{
                        return c.Send("no articles found", menu)
                }</span>
                <span class="cov0" title="0">msg := "random âœ…\n" + link.URL + "\nID: " + link.ID + "\nResource: article"
                return c.Send(msg, menu)</span>
        })

        <span class="cov0" title="0">w.bot.Handle(&amp;btnRandomVideo, func(c tb.Context) error </span><span class="cov0" title="0">{
                ctx := context.Background()
                link, err := w.api.RandomLink(ctx, "video")
                if err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Msg("random video failed")
                        return c.Send("failed to get random video", menu)
                }</span>
                <span class="cov0" title="0">if link.URL == "" </span><span class="cov0" title="0">{
                        return c.Send("no videos found", menu)
                }</span>
                <span class="cov0" title="0">msg := "random âœ…\n" + link.URL + "\nID: " + link.ID + "\nResource: video"
                return c.Send(msg, menu)</span>
        })

        <span class="cov0" title="0">w.bot.Handle(tb.OnText, func(c tb.Context) error </span><span class="cov0" title="0">{
                text := strings.TrimSpace(c.Text())
                if text == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(text, "/") </span><span class="cov0" title="0">{
                        return c.Send("unknown command, try /save, /viewed, /random", menu)
                }</span>
                <span class="cov0" title="0">return c.Send("commands: /save &lt;url&gt;, /viewed &lt;id&gt;, /random [resource]", menu)</span>
        })

        <span class="cov0" title="0">w.bot.Handle(tb.OnPhoto, func(c tb.Context) error </span><span class="cov0" title="0">{
                return c.Send("commands: /save &lt;url&gt;, /viewed &lt;id&gt;, /random [resource]", menu)
        }</span>)

        // reserved for future middleware
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package user

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"
)

type Client struct {
        baseURL string
        http    *http.Client
}

type User struct {
        ID         string `json:"id"`
        TelegramID int64  `json:"telegram_id"`
        Username   string `json:"username,omitempty"`
        FirstName  string `json:"first_name,omitempty"`
        LastName   string `json:"last_name,omitempty"`
        CreatedAt  string `json:"created_at"`
        UpdatedAt  string `json:"updated_at"`
}

type CreateUserRequest struct {
        TelegramID int64  `json:"telegram_id"`
        Username   string `json:"username,omitempty"`
        FirstName  string `json:"first_name,omitempty"`
        LastName   string `json:"last_name,omitempty"`
}

type ExistsResponse struct {
        Exists bool `json:"exists"`
}

func NewClient(baseURL string, timeout time.Duration) *Client <span class="cov0" title="0">{
        return &amp;Client{
                baseURL: strings.TrimRight(baseURL, "/"),
                http:    &amp;http.Client{Timeout: timeout},
        }
}</span>

func (c *Client) GetOrCreateUser(ctx context.Context, telegramID int64, username, firstName, lastName string) (*User, error) <span class="cov0" title="0">{
        reqData := CreateUserRequest{
                TelegramID: telegramID,
                Username:   username,
                FirstName:  firstName,
                LastName:   lastName,
        }

        payload, err := json.Marshal(reqData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/api/v1/users", bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("api status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">var user User
        if err := json.NewDecoder(resp.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (c *Client) GetUserByTelegramID(ctx context.Context, telegramID int64) (*User, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/v1/users/telegram/%d", c.baseURL, telegramID)

        req, err := http.NewRequestWithContext(ctx, "GET", url, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("api status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">var user User
        if err := json.NewDecoder(resp.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (c *Client) UserExists(ctx context.Context, telegramID int64) (bool, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/v1/users/telegram/%d/exists", c.baseURL, telegramID)

        req, err := http.NewRequestWithContext(ctx, "GET", url, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("api status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">var result ExistsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return result.Exists, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package userservice

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type UserModel struct {
        ID         uuid.UUID `gorm:"type:char(36);primary_key" json:"id"`
        TelegramID int64     `gorm:"uniqueIndex;not null" json:"telegram_id"`
        Username   string    `gorm:"type:varchar(255)" json:"username,omitempty"`
        FirstName  string    `gorm:"type:varchar(255)" json:"first_name,omitempty"`
        LastName   string    `gorm:"type:varchar(255)" json:"last_name,omitempty"`
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
}

func (UserModel) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

func (u *UserModel) BeforeCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        if u.ID == uuid.Nil </span><span class="cov0" title="0">{
                u.ID = uuid.New()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "errors"

        "github.com/google/uuid"
        "gorm.io/gorm"

        userservice "github.com/danilovid/linkkeeper/internal/user-service"
)

type userRepo struct {
        db *gorm.DB
}

func NewUserRepo(db *gorm.DB) userservice.Repository <span class="cov10" title="8">{
        return &amp;userRepo{db: db}
}</span>

func (r *userRepo) Create(user *userservice.UserModel) error <span class="cov9" title="7">{
        return r.db.Create(user).Error
}</span>

func (r *userRepo) GetByID(id uuid.UUID) (*userservice.UserModel, error) <span class="cov5" title="3">{
        var user userservice.UserModel
        err := r.db.Where("id = ?", id).First(&amp;user).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov4" title="2">return &amp;user, nil</span>
}

func (r *userRepo) GetByTelegramID(telegramID int64) (*userservice.UserModel, error) <span class="cov4" title="2">{
        var user userservice.UserModel
        err := r.db.Where("telegram_id = ?", telegramID).First(&amp;user).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov1" title="1">return &amp;user, nil</span>
}

func (r *userRepo) Update(user *userservice.UserModel) error <span class="cov1" title="1">{
        return r.db.Save(user).Error
}</span>

func (r *userRepo) Exists(telegramID int64) (bool, error) <span class="cov4" title="2">{
        var count int64
        err := r.db.Model(&amp;userservice.UserModel{}).Where("telegram_id = ?", telegramID).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov4" title="2">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/google/uuid"
        "github.com/gorilla/mux"

        userservice "github.com/danilovid/linkkeeper/internal/user-service"
        "github.com/danilovid/linkkeeper/pkg/logger"
)

type Server struct {
        uc userservice.Usecase
}

func NewServer(uc userservice.Usecase) *Server <span class="cov10" title="8">{
        return &amp;Server{uc: uc}
}</span>

func (s *Server) Handler() http.Handler <span class="cov0" title="0">{
        return s.routes()
}</span>

type CreateUserRequest struct {
        TelegramID int64  `json:"telegram_id"`
        Username   string `json:"username,omitempty"`
        FirstName  string `json:"first_name,omitempty"`
        LastName   string `json:"last_name,omitempty"`
}

type UserResponse struct {
        ID         string `json:"id"`
        TelegramID int64  `json:"telegram_id"`
        Username   string `json:"username,omitempty"`
        FirstName  string `json:"first_name,omitempty"`
        LastName   string `json:"last_name,omitempty"`
        CreatedAt  string `json:"created_at"`
        UpdatedAt  string `json:"updated_at"`
}

type ExistsResponse struct {
        Exists bool `json:"exists"`
}

func (s *Server) GetOrCreateUser(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        var req CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                logger.L().Error().Err(err).Msg("failed to decode request")
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">if req.TelegramID == 0 </span><span class="cov1" title="1">{
                http.Error(w, "telegram_id is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">user, err := s.uc.GetOrCreateUser(req.TelegramID, req.Username, req.FirstName, req.LastName)
        if err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to get or create user")
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">resp := UserResponse{
                ID:         user.ID.String(),
                TelegramID: user.TelegramID,
                Username:   user.Username,
                FirstName:  user.FirstName,
                LastName:   user.LastName,
                CreatedAt:  user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:  user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to encode response")
        }</span>
}

func (s *Server) GetUserByID(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        vars := mux.Vars(r)
        idStr := vars["id"]

        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, "invalid user id", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">user, err := s.uc.GetUserByID(id)
        if err != nil </span><span class="cov1" title="1">{
                logger.L().Error().Err(err).Msg("failed to get user")
                http.Error(w, "user not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov1" title="1">resp := UserResponse{
                ID:         user.ID.String(),
                TelegramID: user.TelegramID,
                Username:   user.Username,
                FirstName:  user.FirstName,
                LastName:   user.LastName,
                CreatedAt:  user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:  user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to encode response")
        }</span>
}

func (s *Server) GetUserByTelegramID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        telegramID := vars["telegram_id"]

        var id int64
        if _, err := fmt.Sscanf(telegramID, "%d", &amp;id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid telegram_id", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := s.uc.GetUserByTelegramID(id)
        if err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to get user by telegram id")
                http.Error(w, "user not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">resp := UserResponse{
                ID:         user.ID.String(),
                TelegramID: user.TelegramID,
                Username:   user.Username,
                FirstName:  user.FirstName,
                LastName:   user.LastName,
                CreatedAt:  user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:  user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to encode response")
        }</span>
}

func (s *Server) CheckUserExists(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        vars := mux.Vars(r)
        telegramID := vars["telegram_id"]

        var id int64
        if _, err := fmt.Sscanf(telegramID, "%d", &amp;id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid telegram_id", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">exists, err := s.uc.UserExists(id)
        if err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to check user existence")
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="2">resp := ExistsResponse{Exists: exists}
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                logger.L().Error().Err(err).Msg("failed to encode response")
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package http

import (
        "net/http"

        "github.com/gorilla/mux"
        "github.com/justinas/alice"
        "github.com/rs/cors"

        "github.com/danilovid/linkkeeper/pkg/logger"
)

func (s *Server) routes() http.Handler <span class="cov0" title="0">{
        r := mux.NewRouter()

        middleware := alice.New(
                logRequest,
                cors.New(cors.Options{
                        AllowedOrigins:   []string{"*"},
                        AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                        AllowedHeaders:   []string{"*"},
                        AllowCredentials: true,
                }).Handler,
        )

        api := r.PathPrefix("/api/v1").Subrouter()

        api.HandleFunc("/users", s.GetOrCreateUser).Methods("POST")
        api.HandleFunc("/users/{id}", s.GetUserByID).Methods("GET")
        api.HandleFunc("/users/telegram/{telegram_id}", s.GetUserByTelegramID).Methods("GET")
        api.HandleFunc("/users/telegram/{telegram_id}/exists", s.CheckUserExists).Methods("GET")

        r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                if _, err := w.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                        logger.L().Error().Err(err).Msg("failed to write health response")
                }</span>
        }).Methods("GET")

        <span class="cov0" title="0">return middleware.Then(r)</span>
}

func logRequest(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.L().Info().
                        Str("method", r.Method).
                        Str("path", r.URL.Path).
                        Msg("request")
                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package usecase

import (
        "github.com/google/uuid"

        userservice "github.com/danilovid/linkkeeper/internal/user-service"
)

type userUsecase struct {
        repo userservice.Repository
}

func NewUserService(repo userservice.Repository) userservice.Usecase <span class="cov10" title="8">{
        return &amp;userUsecase{repo: repo}
}</span>

func (u *userUsecase) CreateUser(telegramID int64, username, firstName, lastName string) (*userservice.UserModel, error) <span class="cov5" title="3">{
        user := &amp;userservice.UserModel{
                TelegramID: telegramID,
                Username:   username,
                FirstName:  firstName,
                LastName:   lastName,
        }

        if err := u.repo.Create(user); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return user, nil</span>
}

func (u *userUsecase) GetUserByID(id uuid.UUID) (*userservice.UserModel, error) <span class="cov1" title="1">{
        return u.repo.GetByID(id)
}</span>

func (u *userUsecase) GetUserByTelegramID(telegramID int64) (*userservice.UserModel, error) <span class="cov1" title="1">{
        return u.repo.GetByTelegramID(telegramID)
}</span>

func (u *userUsecase) GetOrCreateUser(telegramID int64, username, firstName, lastName string) (*userservice.UserModel, error) <span class="cov4" title="2">{
        user, err := u.repo.GetByTelegramID(telegramID)
        if err == nil </span><span class="cov1" title="1">{
                return user, nil
        }</span>

        <span class="cov1" title="1">return u.CreateUser(telegramID, username, firstName, lastName)</span>
}

func (u *userUsecase) UserExists(telegramID int64) (bool, error) <span class="cov4" title="2">{
        return u.repo.Exists(telegramID)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "flag"
        "os"
)

// Config represents system configuration.
type Config struct {
        Env         string // runtime environment
        HTTPAddr    string // address "[host]:port" for HTTP server
        PostgresDSN string // Postgres DSN
}

// New reads config from environment/flags and returns pointer to a new Config.
func New() *Config <span class="cov0" title="0">{
        c := &amp;Config{}

        flag.StringVar(&amp;c.Env, "env", lookupEnvString("ENV", "dev"), "Set runtime environment.")
        flag.StringVar(&amp;c.HTTPAddr, "httpAddr", lookupEnvString("HTTP_ADDR", ":8080"), `Address in form of "[host]:port" that HTTP server should be listening on.`)
        flag.StringVar(
                &amp;c.PostgresDSN,
                "postgresDsn",
                lookupEnvString("POSTGRES_DSN", "postgres://postgres:postgres@localhost:5432/linkkeeper?sslmode=disable"),
                "PostgreSQL DSN.",
        )

        flag.Parse()

        return c
}</span>

func lookupEnvString(k, def string) string <span class="cov0" title="0">{
        if v := os.Getenv(k); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return def</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package postgresql

import (
        "os"
        "path/filepath"
        "sort"
        "strings"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"

        "github.com/danilovid/linkkeeper/pkg/logger"
)

func New(dsn string, models ...any) *gorm.DB <span class="cov0" title="0">{
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.L().Fatal().Err(err).Msg("open database")
        }</span>
        <span class="cov0" title="0">if len(models) &gt; 0 </span><span class="cov0" title="0">{
                if err := db.AutoMigrate(models...); err != nil </span><span class="cov0" title="0">{
                        logger.L().Fatal().Err(err).Msg("auto migrate")
                }</span>
        }
        <span class="cov0" title="0">if err := applyMigrations(db, migrationsDir()); err != nil </span><span class="cov0" title="0">{
                logger.L().Fatal().Err(err).Msg("apply migrations")
        }</span>
        <span class="cov0" title="0">return db</span>
}

func migrationsDir() string <span class="cov0" title="0">{
        if v := os.Getenv("MIGRATIONS_DIR"); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return "migrations"</span>
}

func applyMigrations(db *gorm.DB, dir string) error <span class="cov0" title="0">{
        if err := db.Exec(`
                CREATE TABLE IF NOT EXISTS schema_migrations (
                        version text PRIMARY KEY,
                        applied_at timestamptz NOT NULL DEFAULT now()
                )
        `).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">var files []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasSuffix(entry.Name(), ".sql") </span><span class="cov0" title="0">{
                        files = append(files, entry.Name())
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(files)

        for _, name := range files </span><span class="cov0" title="0">{
                var exists int
                if err := db.Raw(`SELECT 1 FROM schema_migrations WHERE version = ?`, name).Scan(&amp;exists).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if exists == 1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">path := filepath.Join(dir, name)
                content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := db.Exec(string(content)).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := db.Exec(`INSERT INTO schema_migrations (version) VALUES (?)`, name).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package httpclient

import (
        "crypto/tls"
        "net/http"
        "time"
)

const (
        readTimeout  = 5 * time.Second
        writeTimeout = 5 * time.Second
)

func New(httpAddr string, handler http.Handler, tlsConfig *tls.Config) *http.Server <span class="cov0" title="0">{
        return &amp;http.Server{
                ReadTimeout:  readTimeout,
                WriteTimeout: writeTimeout,
                Addr:         httpAddr,
                Handler:      handler,
                TLSConfig:    tlsConfig,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package logger

import (
        "os"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func Init() <span class="cov0" title="0">{
        zerolog.TimeFieldFormat = time.RFC3339Nano
        writer := zerolog.ConsoleWriter{
                Out:        os.Stdout,
                TimeFormat: time.RFC3339Nano,
        }
        log.Logger = log.Output(writer)
}</span>

func L() *zerolog.Logger <span class="cov0" title="0">{
        l := log.Logger
        return &amp;l
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
